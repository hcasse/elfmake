"""ElfMake module providing configuration classes."""
import env
import imp
import os.path
import sys

config_list = []	# list of configuration modules
updated = False


def host():
	"""Return a string identifying the host platform.""" 
	info = os.uname()
	return "%s %s %s %s" % (info[0], info[1], info[2], info[4])

def register(name, config):
	"""Function used to register a configuration."""
	config_list.append((name, config))


def load(do_config):
	"""Called to load the configuration file.
	
	do_config informs it is a load for configuration and
	therefore do not alert user for incompatibility."""
	cpath = env.topdir / "config.py"
	if cpath.exists():
		
		# load the configuration
		mod = imp.load_source('config.py', str(cpath))
		env.confenv.map = mod.__dict__
		
		# check host compatibility
		try:
			h = env.confenv.map['ELF_HOST']
			if h <> None and h <> host():
				
				# warn if we are not in configuration
				if not do_config:
					print "WARNING: config.py for a different host found!\nReconfigure it with ./make.py -c"
					
				# reset configuration else
				else:
					env.confenv.map = { }

		except KeyError, e:
			pass

def make():
	"""Build a configuration."""
	
	# launch module configuration
	for (n, f) in config_list:
		f()
	
	# if needed, output the configuration file
	if updated:
		env.confenv.set("ELF_HOST", host())
		f = open(os.path.join(env.topdir, 'config.py'), "w")
		f.write("# generated by ElfMake\n")
		f.write("# You're ALLOWED modifying this file to tune or complete your configuration\n")
		for k in env.confenv.map:
			if not k.startswith("__"):
				f.write("%s = '%s'\n" % (k, env.confenv.map[k]))
		f.close()


def find_program(label, var, progs, paths = [], syspath = True, sysfirst = True):
	"""Find the path of a program and display associated message.
	
	The label is displayed during the look-up, one of progs
	is look in the given paths including system path if syspath is True.
	If sysfirst is true, look system paths first.
	
	If the variable var already exists and is set, do nothing.
	Else store the result in configuration environment."""
	
	# already exists?
	try:
		path = env.confenv.map[var]
		if path:
			return False
	except KeyError, e:
		pass
	
	# ensure we have a list of programs
	if not isinstance(progs, list):
		progs = [str(progs)]
	
	# include system paths
	if syspath:
		spaths = os.getenv("PATH").split(os.pathsep)
		if sysfirst:
			lpaths = spaths + paths
		else:
			lpaths = paths + spaths
	else:
		lpaths = paths
	
	# lookup
	sys.stdout.write(label + " ... ")
	sys.stdout.flush()
	fpath = None
	for path in lpaths:
		for prog in progs:
			ppath = os.path.join(path, prog)
			if os.access(ppath, os.X_OK):
				if path in paths:
					fpath = ppath
				else:
					fpath = prog
				break
	
	# process result
	env.confenv.set(var, fpath)
	if fpath:
		sys.stdout.write("found: %s\n" % fpath)
		global updated
		updated = True
	else:
		sys.stdout.write("not found!")

